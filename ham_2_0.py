# -*- coding: utf-8 -*-
"""Ham 2 0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xHp-iivbzLItdPTKwdukDAP2bY8lLlEO
"""

import kagglehub
kmader_skin_cancer_mnist_ham10000_path = kagglehub.dataset_download('kmader/skin-cancer-mnist-ham10000')
print('Data source import complete.')

# Commented out IPython magic to ensure Python compatibility.

# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
from glob import glob
import seaborn as sns
from PIL import Image
np.random.seed(123)
from sklearn.preprocessing import label_binarize
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc
from itertools import product
import plotly.express as px
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split

# --- Загрузка данных ---
base_skin_dir = kmader_skin_cancer_mnist_ham10000_path
data_directory = os.path.join(base_skin_dir)

# --- Подготовка данных ---
data = pd.read_csv(os.path.join(data_directory, 'HAM10000_metadata.csv'))

imageid_path_dict = {
    os.path.splitext(os.path.basename(x))[0]: x
    for x in glob(os.path.join(base_skin_dir, '*', '*.jpg'))
}

lesion_type_dict = {
    'nv': 'Меланоформный невус МКБ-10 : D22',
    'mel': 'Меланома кожи МКБ-10 : С43',
    'bkl': 'Доброкачественный кератоз МКБ-10 : L43.9',
    'bcc': 'Базальноклеточный рак кожи МКБ-10 : C44',
    'akiec': 'Актинический кератоз МКБ - 10 : L57.0',
    'vasc': 'Сосудистые новообразования МКБ-10 : Q27.9,Q82.5',
    'df': 'Дерматофиброма МКБ-10 : D23.9'
}

data.describe(include="all")

print(data.isna().any())

print(data.isnull().sum())

skin_data = data.copy()
skin_data['path'] = skin_data['image_id'].map(imageid_path_dict.get)
skin_data['cell_type'] = skin_data['dx'].map(lesion_type_dict)
skin_data['cell_type_idx'] = pd.Categorical(skin_data['cell_type']).codes
skin_data['age'] = skin_data['age'].fillna(skin_data['age'].median())
skin_data['diagnosis_ru'] = skin_data['dx'].map(lesion_type_dict)

# 3. Считаем количество по каждой категории
tmp = skin_data['diagnosis_ru'].value_counts().reset_index()
tmp.columns = ['Заболевание', 'Количество']

# 4. Строим график
fig = px.bar(tmp, x='Заболевание', y='Количество', color='Заболевание',
             title='Распределение заболеваний кожи',
             text_auto=True)

fig.update_layout(
    xaxis_title="Заболевание",
    yaxis_title="Количество изображений",
    legend_title="Заболевания"
)

fig.show()

tmp = skin_data['sex'].value_counts()
tmp = tmp.reset_index()
tmp.columns = ['sex', 'count']

fig = px.pie(tmp, values='count', names='sex', title='Соотношение мужчин и женщин')
fig.show()

# Создаем столбец с русскими названиями
data['dx_ru'] = data['dx'].map(lesion_type_dict)
grouped = data.groupby(['dx_ru', 'sex']).size().unstack()

ax = grouped.plot(kind='bar', stacked=True, figsize=(15, 8), color=sns.color_palette("inferno", 3))

plt.title('Распределение болезней по полу', fontsize=16)
plt.xlabel('Заболевание', fontsize=14)
plt.ylabel('Количество пациентов', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.legend(title='Пол')
plt.show()

plt.figure(figsize=(12, 6))
sns.histplot(skin_data['age'], bins=30, kde=True, color='skyblue')

# Среднее, медиана, минимум и максимум
mean_age = skin_data['age'].mean()
median_age = skin_data['age'].median()
min_age = skin_data['age'].min()
max_age = skin_data['age'].max()

plt.axvline(mean_age, color='red', linestyle='dashed', linewidth=2,
            label=f'Средний возраст: {mean_age:.1f}')
plt.axvline(median_age, color='green', linestyle='dashed', linewidth=2,
            label=f'Медианный возраст: {median_age:.1f}')
plt.axvline(min_age, color='blue', linestyle='dotted', linewidth=2,
            label=f'Минимальный возраст: {min_age}')
plt.axvline(max_age, color='purple', linestyle='dotted', linewidth=2,
            label=f'Максимальный возраст: {max_age}')

plt.title('Распределение возрастов пациентов', fontsize=14)
plt.xlabel('Возраст')
plt.ylabel('Количество пациентов')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Если в 'sex' есть NaN, заполним их значением 'unknown'
skin_data['sex'] = skin_data['sex'].fillna('unknown')


 # Группируем данные
body_part_by_sex = pd.crosstab(index=skin_data['localization'], columns=skin_data['sex'], margins=True)

# Сортируем по общему количеству
body_part_by_sex = body_part_by_sex.sort_values(by='All', ascending=False).drop(index='All')

    # Визуализация
body_part_by_sex[['male', 'female', 'unknown']].plot(kind='barh', figsize=(12, 8),
                                                         color=['#4ECDC4', '#FF6B6B', '#999999'])
plt.title('Локализация заболеваний по полу', fontsize=14)
plt.xlabel('Количество случаев')
plt.ylabel('Часть тела')
plt.gca().invert_yaxis()  # Чтобы самая частая была сверху
plt.legend(['Мужчины', 'Женщины', 'Неизвестный'])
plt.grid(True)
plt.tight_layout()
plt.show()

# --- Загрузка изображений ---
def load_image(path):
    return np.array(Image.open(path).resize((100, 75)))

skin_data['image'] = skin_data['path'].apply(load_image)

n_samples=3
fig, m_axs = plt.subplots(7, n_samples, figsize = (4*n_samples, 3*7))
for n_axs, (type_name, type_rows) in zip(m_axs,skin_data.sort_values(['cell_type']).groupby('diagnosis_ru')):
    n_axs[0].set_title(type_name)
    for c_ax, (_, c_row) in zip(n_axs, type_rows.sample(n_samples, random_state=2018).iterrows()):
        c_ax.imshow(c_row['image'])
        c_ax.axis('off')

# --- Нормализация и разбиение ---
X = np.stack(skin_data['image'])
y = skin_data['cell_type_idx']

X = X.astype('float32') / 255.0
y = to_categorical(y, num_classes=7)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.1, random_state=42)

# --- Аугментация данных ---
datagen = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=True,
    zoom_range=0.2
)
datagen.fit(X_train)

from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization, Activation

# --- Улучшенная модель CNN ---
model = Sequential([
    Conv2D(32, (3,3), input_shape=(75, 100, 3), padding='same'),
    BatchNormalization(),
    Activation('relu'),
    MaxPooling2D(pool_size=(2,2)),

    Conv2D(64, (3,3), padding='same'),
    BatchNormalization(),
    Activation('relu'),
    MaxPooling2D(pool_size=(2,2)),

    Conv2D(128, (3,3), padding='same'),
    BatchNormalization(),
    Activation('relu'),
    MaxPooling2D(pool_size=(2,2)),

    Conv2D(256, (3,3), padding='same'),
    BatchNormalization(),
    Activation('relu'),
    MaxPooling2D(pool_size=(2,2)),

    Flatten(),
    Dense(256),
    BatchNormalization(),
    Activation('relu'),
    Dropout(0.5),

    Dense(7, activation='softmax')
])

model.compile(optimizer=Adam(learning_rate=0.001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# --- Callbacks ---
checkpoint = ModelCheckpoint('/content/drive/MyDrive/models/best_model.keras', save_best_only=True, monitor='val_loss')
early_stop = EarlyStopping(patience=10, restore_best_weights=True)
reduce_lr = ReduceLROnPlateau(factor=0.5, patience=3)

# --- Обучение ---
history = model.fit(datagen.flow(X_train, y_train, batch_size=32),
                    epochs=25,
                    validation_data=(X_val, y_val),
                    callbacks=[checkpoint, early_stop, reduce_lr],
                    verbose=2)

# --- Оценка модели ---
score = model.evaluate(X_test, y_test, verbose=0)
print(f"Тестовая точность: {score[1]:.4f}")

model.save('model.keras')

model.save_weights('model_weights.keras')

# --- График обучения ---
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.tight_layout()
plt.show()

# --- Confusion Matrix ---
Y_pred = model.predict(X_test)
Y_pred_classes = np.argmax(Y_pred, axis=1)
Y_true = np.argmax(y_test, axis=1)

conf_mtx = confusion_matrix(Y_true, Y_pred_classes)
def plot_confusion_matrix(cm, classes, title='Confusion matrix'):
    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)
    thresh = cm.max() / 2.
    for i, j in product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], 'd'), horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

plot_confusion_matrix(conf_mtx, classes=range(7))
plt.show()

# --- Classification Report ---
report = classification_report(Y_true, Y_pred_classes, target_names=lesion_type_dict.values())
print("Classification Report:\n", report)

# --- ROC Curve ---
y_score = model.predict(X_test)
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(7):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

plt.figure(figsize=(10, 8))
colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown', 'pink']
for i, color in enumerate(colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=2,
             label='ROC curve of class {0} (area = {1:0.2f})'
             ''.format(list(lesion_type_dict.values())[i], roc_auc[i]))

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve for Each Class')
plt.legend(loc="lower right")
plt.show()





